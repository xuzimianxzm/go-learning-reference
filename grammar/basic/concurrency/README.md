## Common Threading Model

根据资源访问权限的不同，操作系统会把内存分为内核空间和用户空间，内核空间的指令代码具备直接调度计算机底层资源的能力，比如说 I/O
资源等；用户空间的代码没有访问计算底层资源的能力，需要通过系统调用等方式切换为内核态来实现对计算机底层资源的申请和调度。 线程作为操作系统能够调度的最小单位，也分为用户线程和内核线程：

- 用户线程由用户空间的代码创建、管理和销毁，线程的调度由用户空间的线程库完成(可能是编程语言层次的线程库)，无需切换内核态，资源消耗少且高效。对 CPU 的竞争是以所属进程的维度参与的，同一进程下的所有用户级线程只能分时复用进程被分配的
  CPU 时间片，所以无法很好利用 CPU 多核运算的优势。我们一般情况下说的线程其实是指用户线程；
- 内核线程由操作系统管理和调度，能够直接操作计算机底层的资源，线程切换的时候 CPU 需要切换到内核态。它能够很好利用多核 CPU 并行计算的优势，开发人员可以通过系统调用使用内核线程。

### User-level Threading Model

用户级线程模型中基本是一个进程对应一个内核线程，如下图所示：

![avatar](https://gitee.com/xuzimian/Image/raw/master/Basic/user_level_threadingmodel.jpg)

进程内的多线程管理由用户代码完成，这使得线程的创建、切换和同步等工作显得异常轻量级和高效，但是这些复杂的逻辑需要在用户代码中实现，一般依赖于编程语言层次。同时进程内的多线程无法很好利用 CPU
多核进程的优势，只能通过分时复用的方式轮换执行。当进程内的任意进程阻塞，比如线程 A 请求 I/O 操作被阻塞，很可能导致整个进程范围内的阻塞，因为此时进程对应内核线程因为线程 A 的I/O 阻塞而被剥夺 CPU
执行时间，导致整个进程失去了在 CPU 执行代码的权利！

### Kernel Level Threading Model

内核级线程模型中，进程中的每个线程都会对应一个内核线程，如图所示：

![avatar](https://gitee.com/xuzimian/Image/raw/master/Basic/kernel_level_threading_model.jpg)

进程内每创建一个新的线程都会调用操作系统的线程库在内核创建一个新的内核线程与对应，线程的管理和调度有操作系统负责，这将导致每次线程切换上下文时都会从用户态切换到内核态，会有不小的资源消耗，同时创建线程的数量也会受制于操作系统内核创建可创建的内核线程数量。好处是多线程能够充分利用
CPU 的多核并行计算能力，因为每个线程可以独立被操作系统调度分配到 CPU 上执行指令，同时某个线程的阻塞并不会影响到进程内其他线程工作的执行。

### Two Level Threading Model

两级线程模型相当于用户级线程模式和内核级线程模型的结合，一个进程将会对应多个内核线程，由进程内的调度器决定进程内的线程如何与申请的内核线程对应，如图所示

![avatar](https://gitee.com/xuzimian/Image/raw/master/Basic/two_level_threading_model.jpg)

进程会预先申请一定数量的内核线程，然后将自身创建的线程与内核进程进行对应。线程的调用和管理由进程内的调度器进行，而内核线程的调度和管理由操作系统负责。这种线程模型即能够有效降低线程创建和管理的资源消耗，也能够很好提供线程并行计算的能力，但是给开发人员带来较大的实现难度。

### MPG Threading Model

Go 中的 MPG 线程模型对两级线程模型进行一定程度的改进，使它能够更加灵活地进行线程之间的调度。它由三个主要模块构成，如图所示:

![avatar](https://gitee.com/xuzimian/Image/raw/master/golang/MPG_threading_model.jpg)

- machine，一个 machine 对应一个内核线程，相当于内核线程在 Go 进程中的映射
- processor，一个 prcessor 表示执行 Go 代码片段的所必需的上下文环境，可以理解为用户代码逻辑的处理器
- goroutine，是对 Go 中代码片段的封装，其实是一种轻量级的用户线程。

为了减轻描述工作，下面的介绍中我们会用 M、P、G 分别指代 machine、processor 和 goroutine。从图中可以看出： 每一个 M 都会以一个内核线程绑定，M 和 P 之间也是一对一的关系，而 P 和 G
的关系则是一对多。在运行过程中，M 和 内核线程之间对应关系的不会变化，在 M 的生命周期内，它只会与一个内核线程绑定，而 M 和 P 以及 P 和 G 之间的关系都是动态可变的。 在实际的运行过程中，M 和 P 的组合才能够为 G
提供有效的运行环境，而多个可执行 G 将会顺序排成一个队列挂在某个 P 上面，等待调度和执行，如下图所示：

![avatar](https://gitee.com/xuzimian/Image/raw/master/golang/MPG_threading_relation.jpg)

上图中，M 和 P 共同构成了一个基本的运行环境，此时 G0 中的代码片段处于正在运行的状态，而右边的 G 队列处于待执行状态。 M 的创建一般是因为没有足够的 M 来和 P 组合以为 G 提供运行环境，在很多时候 M 的数量可能会比 P
要多。在单个 Go 进程中，P 的最大数量决定了程序的并发规模，且 P 的最大数量是由程序决定的。可以通过修改环境变量 GOMAXPROCS 和 调用函数 runtime#GOMAXPROCS 来设定 P 的最大值。 M 和 P
会适时的组合和断开，保证 P 中的待执行 G 队列能够得到及时运行。比如说上图中的 G0 此时因为网络 I/O 而阻塞了 M，那么 P 就会携带剩余的 G 投入到其他 M 的怀抱中。这个新的 M1 可能是新创建的，也可能是从调度器空闲 M
列表中获取的，取决于此时的调度器空闲 M 列表中是否存在 M，从而避免 M 的过多创建，如图所示:

![avatar](https://gitee.com/xuzimian/Image/raw/master/golang/MPG_threading_flow.jpg)

当 M 对应的内核线程被唤醒时，M 将会尝试为 G0 捕获一个 P 上下文，可能是从调度器的空闲 P 列表中获取，如果获取不成功，M 会被 G0 放入到调度器的可执行 G 队列中，等待其他 P 的查找。为了保证 G 的均衡执行，非空闲的 P
会运行完自身的可执行 G 队列中，会周期性从调度器的可执行 G 队列中获取代执行的 G，甚至从其他的 P 的可执行 G 队列中掠夺 G！

> Notes: Go 语言并发的真理是：不要以共享内存的方式来通信，相反，要通过通信来共享内存。当一个 P 关联多个 G 时，就会处理 G 的执行顺序，就是并发，当一个 P 在执行一个协程工作时，其他的会在等待，当正在执行的协程遇到阻塞情况，例如 IO 操作等，Go 的处理器就会去执行其他的协程，因为对于类似 IO 的操作，处理器不知道你需要多久才能执行结束，所以他不回去等你执行完。


